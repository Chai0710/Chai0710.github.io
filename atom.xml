<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chai&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://chaichai.site/"/>
  <updated>2019-10-30T03:54:02.309Z</updated>
  <id>https://chaichai.site/</id>
  
  <author>
    <name>Chai Wei-Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RESTful API</title>
    <link href="https://chaichai.site/2019/10/27/restful_api/"/>
    <id>https://chaichai.site/2019/10/27/restful_api/</id>
    <published>2019-10-26T16:00:00.000Z</published>
    <updated>2019-10-30T03:54:02.309Z</updated>
    
    <content type="html"><![CDATA[<p>為了理解目前 API 設計的主流，試著整理了網路上的解說文章，作為學習筆記。</p><a id="more"></a><hr><h2 id="何謂-RESTful"><a href="#何謂-RESTful" class="headerlink" title="何謂 RESTful?"></a>何謂 RESTful?</h2><p>簡單來說，就是把每個網址當做資源（Resource）來看待，對同一個資源做不同的動作（HTTP Verb）會得到不同的結果。<br>符合 REST 概念設計的網址，又稱之 RESTful Route。</p><br><ul><li><p>REST 全名</p><ul><li>Resource : 資源</li><li>Representational : JSON, XML, YAML..</li><li>State Transfer : 狀態傳輸，透過 HTTP 動詞實現</li></ul></li></ul><ul><li><p>API 範例</p><ul><li>非 RESTful 的 API 可能長這樣：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/api/get_file/ ( 得到檔案 )</span><br><span class="line">/api/upload_file/ ( 新增檔案 )</span><br><span class="line">/api/update_file/ ( 更新檔案 )</span><br><span class="line">/api/delete_file/ ( 刪除檔案 )</span><br></pre></td></tr></table></figure><ul><li>RESTful API ：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/api/files/ ( GET -&gt; 得到檔案 )</span><br><span class="line">/api/files/ ( POST -&gt; 新增檔案 )</span><br><span class="line">/api/files/ ( PUT -&gt; 更新檔案)</span><br><span class="line">/api/files/ ( DELETE -&gt; 刪除檔案 )</span><br></pre></td></tr></table></figure></li></ul><br><h3 id="RESTful-Triangle"><a href="#RESTful-Triangle" class="headerlink" title="RESTful Triangle"></a>RESTful Triangle</h3><p><img src="https://image.slidesharecdn.com/asitrest-150317020843-conversion-gate01/95/learn-rest-api-at-asit-6-638.jpg?cb=1426576159" alt="相關圖片"></p><ol><li>Nouns 名詞：定義網址的 URL，每個資源僅有一個唯一的識別位置，就像家的住址。</li><li>Verbs 動詞：描述了對 Nouns 名詞 (資源 URL) 的操作動作，在 HTTP 1.1 的實作就是 HTTP Method。</li><li>Content Types 資源呈現方式：比如取得某一個 URL 文章的 HTML 格式、或者 XML 格式，同樣的 URL 資源可以有不同型態的表現方式。</li></ol><p>建議在設計 API 規格時，同時思考上述的設計原則，好讓 API 設計更接近 REST 精神。</p><br><hr><br><h2 id="RESTful-API-設計要點"><a href="#RESTful-API-設計要點" class="headerlink" title="RESTful API 設計要點"></a>RESTful API 設計要點</h2><br><h3 id="HTTP-動詞"><a href="#HTTP-動詞" class="headerlink" title="HTTP 動詞"></a>HTTP 動詞</h3><p>在<em>HTTP*通訊協定中制定了九種動詞</em>(Verbs)<em>來跟伺服器溝通，分別是</em>HEAD*、_GET_、_POST_、_PUT_、_PATCH_、_DELETE_、_TRACE_、_OPTIONS_、_CONNECT_。</p><ul><li>常用的 HTTP method：</li></ul><table><thead><tr><th align="left">HTTP</th><th>Method Idempotent</th><th>Safe</th></tr></thead><tbody><tr><td align="left">GET（讀取資源）</td><td>yes</td><td>yes</td></tr><tr><td align="left">HEAD（類似 GET，但只回傳 HTTP header）</td><td>yes</td><td>yes</td></tr><tr><td align="left">PUT （替換資源）</td><td>yes</td><td>no</td></tr><tr><td align="left">POST（新增資源）</td><td>no</td><td>no</td></tr><tr><td align="left">DELETE（刪除資源）</td><td>yes</td><td>no</td></tr><tr><td align="left">PATCH（更新資源部份內容）</td><td>no</td><td>no</td></tr></tbody></table><ul><li><p>Safe / Idempotent</p><ul><li><p>「safe」是指該操作不會改變伺服器端的資源狀態（而且結果可以被 cache）</p></li><li><p>「idempotent」是指該操作不管做 1 遍或做 n 遍，都會得到同樣的資源狀態結果（但不一定得到同樣的回傳值，例如第 2 次 DELETE 請求可能回傳 404），因此 client 端可以放心 retry。</p></li></ul></li></ul><ul><li><p>PUT、POST 和 PATCH 容易混淆，補充說明如下：</p><ol><li><strong>PUT</strong>通常是用來替換單一資源或資源集合 (resource collection) 的內容。</li><li><strong>POST</strong>除了用來新增資源，也作為 catch-all 用途，例如用在 utility API。（Utility API 是不同於一般資源讀寫操作的要求類型，例如檢查某個促銷活動碼是否有效。）</li><li><strong>PATCH</strong>用來更新資源部份內容。前幾年有人會用 POST 代替 PATCH，現在應該沒這必要了；建議除非 infrastructure 有限制，否則直接用 PATCH 即可。</li></ol></li></ul><br><h3 id="URI-名詞"><a href="#URI-名詞" class="headerlink" title="URI 名詞"></a>URI 名詞</h3><p>相對於 HTTP 動詞，URI 就是名詞了。URI 由 prefix + API endpoint 組成。Prefix 的部份可有可無，例如<code>/api</code>或<code>/api/v1</code>。API endpoint 的設計，幾個重要原則如下：</p><ul><li>一般資源用複數名詞，例如 <code>/books</code> 或 <code>/books/123</code><ul><li>有些人認為用單數比較好，因為<code>/book/123</code>看似比<code>/books/123</code>合理；但想想檔案系統的目錄命名（例如<code>/Users</code>或<code>/Documents</code>），其實用複數也沒問題。複數可以保持 API endpoint 的一致性，所以一般資源建議用複數。</li></ul></li><li>唯一資源（亦即對 client 而言只有一份的資源）用<strong>單數名詞</strong>。例如<a href="https://developer.github.com/v3/activity/watching/#list-repositories-being-watched" target="_blank" rel="noopener">GitHub watching API</a>中的<code>GET /user/subscriptions</code>，其中<code>user</code>是指目前驗證的使用者，所以用單數。</li><li>資源的層級架構，可以適當反應在 API endpoint 設計上，例如<code>/books/123/chapters/2</code>。</li><li>Utility API 與 resource API 性質不同，它的 endpoint 設計只要合理即可，例如<code>/search?q={keywords}</code>。</li><li>建議 URI components 都用<strong>小寫</strong>，兩個字之間用減號<code>-</code>或底線<code>_</code>隔開皆可，但應保持一致。（我個人偏好用<code>-</code>）</li></ul><br><h3 id="HTTP-回傳狀態碼"><a href="#HTTP-回傳狀態碼" class="headerlink" title="HTTP 回傳狀態碼"></a>HTTP 回傳狀態碼</h3><p>API 回傳的結果，應使用適當的 HTTP 狀態碼，所以 API 設計者必須了解它們。以下是一些常用的狀態碼，完整列表請參考<a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="noopener">Wikipedia</a>。</p><ul><li><p>2xx: 成功</p><ul><li>200 OK: 通用狀態碼</li><li>201 Created: 資源新增成功</li><li>202 Accepted: 請求已接受，但尚在處理中</li><li>204 No Content: 請求成功，但未回傳任何內容</li></ul></li><li><p>3xx: 重新導向</p><ul><li>301 Moved Permanently: 資源已移至它處</li><li>303 See Other: 回傳的內容可在它處取得（例如在用戶端發送了一個 POST 請求之後）</li><li>304 Not Modified: 請求的資源並未修改（通常是用戶端發送了帶有 If-Modified-Since 或 If-None-Match 表頭的請求）</li></ul></li><li><p>4xx: 用戶端錯誤</p><p>（用戶端不應 retry 原始請求）</p><ul><li>400 Bad Request: 通用狀態碼</li><li>401 Unauthorized: 用戶端尚未驗證*</li><li>403 Forbidden: 用戶端被禁止此請求*</li><li>404 Not Found: 請求的資源不存在</li><li>405 Method Not Allowed: 不支援請求的 HTTP 方法</li><li>406 Not Acceptable: 不支援請求所<strong>要求</strong>的內容類型*（Accept 表頭）</li><li>415 Unsupported Media Type: 不支援請求所<strong>用</strong>的內容類型*（Content-Type 表頭）</li></ul></li><li><p>5xx: 伺服器錯誤</p><p>（用戶端可合理 retry）</p><ul><li>500 Internal Server Error: 工程師要找 bug 了</li><li>501 Not Implemented: 用戶端的請求目前未支援（也就是將來有可能支援）</li><li>502 Bad Gateway: 上游的伺服器未回傳正確結果，一般是 gateway 或 proxy server 才會回傳此狀態碼</li><li>503 Service Unavailable: 暫停服務（也就是過不久就會恢復服務 ── 如果一切順利的話）</li><li>504 Gateway Timeout: 上游的伺服器逾時，一般是 gateway 或 proxy server 才會回傳此狀態碼</li></ul></li></ul><p>* 關於幾個容易混淆的狀態碼，補充說明如下：</p><ol><li>401、403: 401 是指用戶端尚未驗證，也就是 unauthenticated（HTTP spec 裡用 unauthorized 有些誤導）；403 是指用戶端目前的身份不被允許此項請求（通常是用戶端已驗證過了），或是所有使用者都不被允許此項請求。</li><li>406、415: 406 是指用戶端要求「回傳」的 Content-Type（也就是用戶端在 Accept 表頭裡所要求的），伺服器不支援；415 是指用戶端送出的「請求」，其 Content-Type（也就是用戶端 HTTP request body 的內容類型），伺服器不支援。</li></ol><p>另外要注意，這些回傳的狀態碼，是代表 API 這一層的執行狀態，而<strong>不是商業邏輯</strong>這一層的狀態。例如當<code>/search?q=xyz</code>搜尋結果是空的，API 結果仍應回傳 200，而非 404；因為從 API 角度來看，<code>/search</code>這個「資源」存在，而且 API 執行成功。</p><br><h3 id="HTTP-Header"><a href="#HTTP-Header" class="headerlink" title="HTTP Header"></a>HTTP Header</h3><p>用戶端送出 API 請求時，可能會帶一些 HTTP header，例如：</p><ul><li>Accept: 能夠接受的回應內容類型 (Content-Type)，屬於內容協商的一環</li><li>Authorization: 認證資訊</li></ul><p>至於 API 回傳結果的 HTTP header，沒甚麼特別之處，按照一般原則處理即可（例如 Content-Type、Content-Length、ETag、Cache-Control…）。</p><br><h3 id="HTTP-Body-JSON-或-XML-格式"><a href="#HTTP-Body-JSON-或-XML-格式" class="headerlink" title="HTTP Body: JSON 或 XML 格式"></a>HTTP Body: JSON 或 XML 格式</h3><p>現在 JSON 已被普遍支援，加上 JSON 處理上較簡潔，所以越來越多人採用 JSON 作為 API 的 HTTP body 格式。但要採用 JSON 或 XML（或同時支援兩種格式），仍應視專案的實際需求而定。</p><br><h3 id="其它原則"><a href="#其它原則" class="headerlink" title="其它原則"></a>其它原則</h3><ol><li>與 HTTP 一樣，API 應該是 stateless，也就是一項工作單元不應由二個或二個以上 API 組成。（這也引申出一個有趣的問題：REST API 如何支援 transaction？這個問題超出本篇文章的範圍，以後有機會再談。）</li><li>REST API 所呈現的資源，是從應用面及 client 角度來思考，並不需要和後端的資源儲存形式（例如資料庫 schema）維持一對一的關係。</li><li><a href="https://en.wikipedia.org/wiki/Representational_state_transfer#Uniform_interface" target="_blank" rel="noopener">HATEOAS</a> (Hypermedia as the engine of application state) 雖然是 REST 原始定義裡的一環，但我認為不一定需要。</li><li>Query parameter 的部份，只要風格保持一致即可，REST 對此並無特殊規範。</li></ol><br><hr><br><h2 id="RESTful-架構的實踐"><a href="#RESTful-架構的實踐" class="headerlink" title="RESTful 架構的實踐"></a>RESTful 架構的實踐</h2><br><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP 1.1 本身就是 REST 架構的實踐，我們可以遵循它定義好的規格，例如：</p><ul><li>透過 HTTP Status Code 回傳 API 執行結果</li><li>利用 HTTP Accept Header 告知 Server 指定回傳的資料格式 Content-type，JSON 可以送出 application/json、XML 可以送出 application/xml 等等</li><li>透過 POST 新增資料到 Server，執行成功後回傳 201 Status Code 並且透過 Location Header 告知新資源的 URL</li></ul><br><h3 id="優缺點"><a href="#優缺點" class="headerlink" title="優缺點"></a>優缺點</h3><ul><li>優點：<ul><li>網址更直觀，不同開發人員都遵照慣例設計網址，易於維護、擴展。</li><li>REST 設計將每一個實體定義獨立唯一的 URL 位置，物件資源相互的依賴性降低，API 解耦特性更好，容易彈性組合應付多數業務邏輯。</li></ul></li><li>缺點<ul><li>安全性問題，假設使用者知道 <code>/member/1</code> 是自己的會員資料，他就可以嘗試從 <code>/member/100</code> 得到其他用戶的資料，須對使用者做身份驗證。</li><li>資源相依結構鬆散問題，假設想要取得文章與作者資訊，就必須先 <code>GET /文章/{ID}</code> ，然後再透過取回的文章物件中的 Author 欄位再一次呼叫 <code>GET /使用者/{NAME}</code> 取得作者資訊，較為麻煩。</li></ul></li></ul><br><hr><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://railsbook.tw/chapters/11-routes.html#restful-routes" target="_blank" rel="noopener">https://railsbook.tw/chapters/11-routes.html#restful-routes</a></p><p><a href="https://ihower.tw/rails/restful.html" target="_blank" rel="noopener">https://ihower.tw/rails/restful.html</a></p><p><a href="https://tw.twincl.com/programming/*641y" target="_blank" rel="noopener">https://tw.twincl.com/programming/*641y</a></p><p><a href="https://github.com/twtrubiks/django-rest-framework-tutorial/tree/master/RESTful-API-Tutorial" target="_blank" rel="noopener">https://github.com/twtrubiks/django-rest-framework-tutorial/tree/master/RESTful-API-Tutorial</a></p><p><a href="https://www.webguide.nat.gov.tw/News_Content.aspx?n=531&amp;s=2918" target="_blank" rel="noopener">https://www.webguide.nat.gov.tw/News_Content.aspx?n=531&amp;s=2918</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;為了理解目前 API 設計的主流，試著整理了網路上的解說文章，作為學習筆記。&lt;/p&gt;
    
    </summary>
    
    
      <category term="學習日誌" scheme="https://chaichai.site/categories/%E5%AD%B8%E7%BF%92%E6%97%A5%E8%AA%8C/"/>
    
    
      <category term="Rails" scheme="https://chaichai.site/tags/Rails/"/>
    
      <category term="學習日誌" scheme="https://chaichai.site/tags/%E5%AD%B8%E7%BF%92%E6%97%A5%E8%AA%8C/"/>
    
      <category term="Web" scheme="https://chaichai.site/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Ruby Self</title>
    <link href="https://chaichai.site/2019/10/25/ruby_self/"/>
    <id>https://chaichai.site/2019/10/25/ruby_self/</id>
    <published>2019-10-24T16:00:00.000Z</published>
    <updated>2019-10-27T09:50:15.292Z</updated>
    
    <content type="html"><![CDATA[<p>學 Ruby 時，時常在不同的方法中看到某個神秘變數 self ，self 到底是誰呢？</p><a id="more"></a><hr><h1 id="何謂-Self"><a href="#何謂-Self" class="headerlink" title="何謂 Self ?"></a>何謂 Self ?</h1><p>Ruby 的官方 API 中這麼寫道：</p><blockquote><p>self 是「當前的物件」，以及當沒有明確指定接收者時，訊息（方法呼叫）的預設接收者。 self 所在的上下文決定 self 所代表的物件。</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">upcase_and_reverse</span></span></span><br><span class="line">    upcase.reverse</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在這個方法中，upcase 這個訊息會被傳到 self，而 self 就是任何呼叫該方法的字串。</p><br><hr><br><h2 id="什麼是「目前的物件」？"><a href="#什麼是「目前的物件」？" class="headerlink" title="什麼是「目前的物件」？"></a>什麼是「目前的物件」？</h2><ul><li>單純地印出 self<br>self 指的是 main ，即是 object 的實體</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p <span class="keyword">self</span></span><br><span class="line"><span class="comment"># main</span></span><br><span class="line">p <span class="keyword">self</span>.<span class="keyword">class</span></span><br><span class="line"><span class="comment"># Object</span></span><br></pre></td></tr></table></figure><br><ul><li>在一個 class / module 中<br>self 指的是該 class / module</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span></span><br><span class="line">  p <span class="keyword">self</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># Dog</span></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Bird</span></span></span><br><span class="line">  p <span class="keyword">self</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># Bird</span></span><br></pre></td></tr></table></figure><br><ul><li>在實體方法中<br>self 指的是當前 class 的實體</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">instance_method</span></span></span><br><span class="line">    <span class="keyword">self</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">black = Dog.new</span><br><span class="line">black.instance_method</span><br><span class="line"><span class="comment"># &lt;Dog:0x00007f85540ede78&gt;</span></span><br><span class="line">black.instance_method == black</span><br><span class="line"><span class="comment"># true</span></span><br></pre></td></tr></table></figure><br><ul><li>在類別方法中<br>self 指的是當前的 class</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Dog</span><br><span class="line">  def self.class_method</span><br><span class="line">    self</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line">Dog.class_method</span><br><span class="line"># Dog</span><br><span class="line">Dog.class_method == Dog</span><br><span class="line"># true</span><br></pre></td></tr></table></figure><br><ul><li>混合類型的實體方法<br>即使是在 module 中定義了 hello 方法，self 仍是它所混合的 class 的實體</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module Greeting</span><br><span class="line">  def hello</span><br><span class="line">    self</span><br><span class="line">  end</span><br><span class="line">end</span><br><span class="line">class Dog</span><br><span class="line">  include Greeting</span><br><span class="line">end</span><br><span class="line">black = Dog.new</span><br><span class="line">black.hello</span><br><span class="line"># &lt;Dog:0x00007fdccc93b3d0&gt;</span><br><span class="line">black.hello == black</span><br><span class="line"># true</span><br></pre></td></tr></table></figure><br><ul><li>混合類型的類別方法<br>當 extend class 的方法時，self 的行為與普通的類別方法完全一樣</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Greeting</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">hello</span></span></span><br><span class="line">    <span class="keyword">self</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span></span><br><span class="line">  extend Greeting</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Dog.hello</span><br><span class="line"><span class="comment"># Dog</span></span><br><span class="line">Dog.hello == Dog</span><br><span class="line"><span class="comment"># true</span></span><br></pre></td></tr></table></figure><blockquote><p>在 Ruby 中， module 跟 class 都是物件，不論在 class 或 module，self 都是引用它所在的上下文的實體。</p></blockquote><br><hr><br><h2 id="什麼是「訊息的預設接收者」？"><a href="#什麼是「訊息的預設接收者」？" class="headerlink" title="什麼是「訊息的預設接收者」？"></a>什麼是「訊息的預設接收者」？</h2><ul><li>在一個類別方法中<br>self 指的是 Dog ，因此 self.sleep 等於 Dog.sleep</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">sleep</span></span></span><br><span class="line">    puts <span class="string">'zzz'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">Dog</span>.<span class="title">sleep</span></span></span><br><span class="line">    puts <span class="string">'zzz'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><br><ul><li>呼叫類別方法，當有明確的接收者時<br>可以用 self 去呼叫 sleep() 這個類別方法</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">sleep</span></span></span><br><span class="line">    puts <span class="string">'zzz'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  Dog.sleep</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># zzz</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">sleep</span></span></span><br><span class="line">    puts <span class="string">'zzz'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">self</span>.sleep</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># zzz</span></span><br></pre></td></tr></table></figure><br><ul><li>呼叫類別方法，當沒有明確的接收者時<br>在 class Dog 中， self 指的是 Dog，所以可以省略 self。<br>因為沒有傳訊息或接收者物件的小數點符號，當呼叫沒有接收者的方法時，訊息會傳給當前的值。由於當前的值是 Dog（預設接收者），可以直接呼叫類別方法 sleep。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">sleep</span></span></span><br><span class="line">    puts <span class="string">'zzz'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  sleep</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># zzz</span></span><br></pre></td></tr></table></figure><br><blockquote><p>在 Ruby 中，呼叫方法是以 obj.method 的方式，用一個小數點標記，左邊是接收者，右邊是方法。<br>但是，當接收者是 self 的時候，可以省略接收者和小數點。Ruby 將 self 當做預設的接收者，代表訊息會傳給 self。method == self.method。<br>必須注意的是，在呼叫寫入方法時（以等號結束的方法），即使是傳訊息給當前的 self ，也不能省略。<br>例如：呼叫方法 abc =，要寫成 self.abc = “hello”。如果寫成 abc = “hello” ，Ruby 會解讀爲對局部變數的賦值。</p></blockquote><br><hr><p>參考資料：<br><a href="https://ruby-doc.org/docs/keywords/1.9/Object.html#method-i-self" target="_blank" rel="noopener">https://ruby-doc.org/docs/keywords/1.9/Object.html#method-i-self</a><br><a href="https://rubyplus.com/articles/4861-Ruby-Basics-The-Default-Receiver" target="_blank" rel="noopener">https://rubyplus.com/articles/4861-Ruby-Basics-The-Default-Receiver</a><br><a href="https://www.honeybadger.io/blog/ruby-self-cheat-sheet/" target="_blank" rel="noopener">https://www.honeybadger.io/blog/ruby-self-cheat-sheet/</a><br><a href="https://www.iteye.com/blog/fantaxy025025-1108639" target="_blank" rel="noopener">https://www.iteye.com/blog/fantaxy025025-1108639</a><br><a href="http://www.52help.net/tw/ruby/63.mhtml" target="_blank" rel="noopener">http://www.52help.net/tw/ruby/63.mhtml</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;學 Ruby 時，時常在不同的方法中看到某個神秘變數 self ，self 到底是誰呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="學習日誌" scheme="https://chaichai.site/categories/%E5%AD%B8%E7%BF%92%E6%97%A5%E8%AA%8C/"/>
    
    
      <category term="Ruby" scheme="https://chaichai.site/tags/Ruby/"/>
    
      <category term="Rails" scheme="https://chaichai.site/tags/Rails/"/>
    
      <category term="學習日誌" scheme="https://chaichai.site/tags/%E5%AD%B8%E7%BF%92%E6%97%A5%E8%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Duck Typing</title>
    <link href="https://chaichai.site/2019/10/24/ducktyping/"/>
    <id>https://chaichai.site/2019/10/24/ducktyping/</id>
    <published>2019-10-23T16:00:00.000Z</published>
    <updated>2019-10-27T09:50:25.687Z</updated>
    
    <content type="html"><![CDATA[<p>「當看到一隻鳥走起來像鴨子、游泳起來像鴨子、叫起來也像鴨子，那麼這隻鳥就可以被稱為鴨子。」</p><a id="more"></a><hr><p>簡單來說，假設有一隻鳥，他會游泳、會叫，而我們定義的鴨子需要會游泳、會叫，就可以說那隻鳥是鴨子，即使它可能是一隻企鵝。</p><p>我們並不在乎他是否繼承自鴨子的血緣，到底是不是鴨子，只在乎他的「行為」。</p><p>比如在 Ruby 等程式語言中，有中括號 [ ] 取值的方法，除了陣列以外，字串、Hash 等物件都可以使用，甚至是在自訂的 class 中寫入中括號的方法，不管它的型別是什麼，只要具備中括號的方法，就可以使用。</p><br><p>以下的範例體現了鴨子測試，只要有 quack, feathers 方法，對 <code>in_the_forest</code> 函式而言，該物件就是一個鴨子。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quack</span></span></span><br><span class="line">        puts <span class="string">"這鴨子正在嘎嘎叫"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">feathers</span></span></span><br><span class="line">        puts <span class="string">"這鴨子擁有白色和灰色的羽毛"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quack</span></span></span><br><span class="line">        puts <span class="string">"這人正在模仿鴨子"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">feathers</span></span></span><br><span class="line">        puts <span class="string">"這人在地上拿起1根羽毛然後给其他人看"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">in_the_forest</span><span class="params">(duck)</span></span></span><br><span class="line">    duck.quack</span><br><span class="line">    duck.feathers</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">game</span></span></span><br><span class="line">    duck = Duck.new</span><br><span class="line">    person = Person.new</span><br><span class="line">    in_the_forest(duck)</span><br><span class="line">    in_the_forest(person)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">game</span><br><span class="line"></span><br><span class="line"><span class="comment"># 這鴨子正在嘎嘎叫</span></span><br><span class="line"><span class="comment"># 這鴨子擁有白色和灰色的羽毛</span></span><br><span class="line"><span class="comment"># 這人正在模仿鴨子</span></span><br><span class="line"><span class="comment"># 這人在地上拿起1根羽毛然後给其他人看</span></span><br></pre></td></tr></table></figure><br><p>只是，由於鴨子型別所帶來的方便與靈活度，也可能早成難以檢測的錯誤，開發者需注意不同類別中相同方法的可能使用。<br><br></p><hr><p>參考資料<br><a href="https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;「當看到一隻鳥走起來像鴨子、游泳起來像鴨子、叫起來也像鴨子，那麼這隻鳥就可以被稱為鴨子。」&lt;/p&gt;
    
    </summary>
    
    
      <category term="學習日誌" scheme="https://chaichai.site/categories/%E5%AD%B8%E7%BF%92%E6%97%A5%E8%AA%8C/"/>
    
    
      <category term="Ruby" scheme="https://chaichai.site/tags/Ruby/"/>
    
      <category term="Rails" scheme="https://chaichai.site/tags/Rails/"/>
    
      <category term="OO" scheme="https://chaichai.site/tags/OO/"/>
    
      <category term="學習日誌" scheme="https://chaichai.site/tags/%E5%AD%B8%E7%BF%92%E6%97%A5%E8%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Ruby Symbol</title>
    <link href="https://chaichai.site/2019/10/23/ruby_symbol/"/>
    <id>https://chaichai.site/2019/10/23/ruby_symbol/</id>
    <published>2019-10-22T16:00:00.000Z</published>
    <updated>2019-10-27T09:50:20.736Z</updated>
    
    <content type="html"><![CDATA[<p>在學 Ruby 時，常常會看到 :name 等，前面帶有冒號的字，那到底是什麼呢？</p><a id="more"></a><hr><h2 id="何謂-Symbol"><a href="#何謂-Symbol" class="headerlink" title="何謂 Symbol"></a>何謂 Symbol</h2><p>Ruby 的官方 API 中這麼寫道：</p><blockquote><p>Symbol 物件表示 Ruby 直譯器中的「名稱」及某些「字串」。<br>Symbol 可以用：name 和：“string” 語法以及各種 to_sym 方法生成。無論內容或含義為何，都會在程序執行的期間為該名稱或字串創建相同的 Symbol 物件。因此，假設 Fred 在一個 context 中是一個常數，在一個 context 中是方法，也是另一個 context 的類別， Symbol：Fred 全都是相同的物件。</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">One</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Fred</span></span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  $f1 = <span class="symbol">:Fred</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Two</span></span></span><br><span class="line">  Fred = <span class="number">1</span></span><br><span class="line">  $f2 = <span class="symbol">:Fred</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Fred</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">$f3 = <span class="symbol">:Fred</span></span><br><span class="line">$f1.object_id        <span class="comment"># 2514190</span></span><br><span class="line">$f2.object_id        <span class="comment"># 2514190</span></span><br><span class="line">$f3.object_id        <span class="comment"># 2514190</span></span><br></pre></td></tr></table></figure><ul><li>Symbol 就是一個 Symbol class 的實體。</li><li>Symbol 不是變數，是「帶有名字的物件」，本質上就是「值」，不需要也不能指向任何東西。（變數則是指向某物件的名字，無法單獨存在。）</li><li>Symbol 即使被重複使用，也都是同一個物件，object_id 不會變，不會消耗多餘的記憶體。</li></ul><br><h3 id="Symbol-的取得方式"><a href="#Symbol-的取得方式" class="headerlink" title="Symbol 的取得方式"></a>Symbol 的取得方式</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:symbol</span></span><br><span class="line"><span class="symbol">:<span class="string">'symbol'</span></span></span><br><span class="line">%s!symbol!    <span class="comment"># %記法</span></span><br><span class="line"><span class="comment"># 可使用 Symbol.all_symbols 取得所有已生成的 Symbol 列表。</span></span><br></pre></td></tr></table></figure><ul><li>當宣告新的變數 / 方法 / 類別時，Ruby 會偷偷新增新的 Symbol</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">im_chai = <span class="string">"Chai"</span></span><br><span class="line">Symbol.all_symbols.map(&amp;<span class="symbol">:to_s</span>).<span class="keyword">include</span>?(<span class="string">"im_chai"</span>)   <span class="comment"># true</span></span><br></pre></td></tr></table></figure><br><h3 id="Symbol-的命名規則"><a href="#Symbol-的命名規則" class="headerlink" title="Symbol 的命名規則"></a>Symbol 的命名規則</h3><blockquote><p>Symbol 的表現方法為「：」後跟一個標識符，一個方法名稱（包括如「！」「？」「=」等等的後綴詞），一個變數名（包括如「$」的前綴詞等），英文或非英文皆可。唯一例外的是， Symbol 不接受「\」字元。</p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:LOCK_SH</span></span><br><span class="line"><span class="symbol">:</span>$&lt;</span><br><span class="line"><span class="symbol">:</span>こんにちは</span><br><span class="line"><span class="symbol">:</span>”Good Day”</span><br></pre></td></tr></table></figure><br><hr><br><h2 id="Symbol-與-String-的比較"><a href="#Symbol-與-String-的比較" class="headerlink" title="Symbol 與 String 的比較"></a>Symbol 與 String 的比較</h2><ul><li>相同 Symbol 指向的都是同一個記憶體，相同的 String 在每次產生時，都是在不同記憶體位置的不同物件。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>.times <span class="keyword">do</span></span><br><span class="line">  puts <span class="string">"hello"</span>.object_id</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 70199659402580</span></span><br><span class="line"><span class="comment"># 70199659366640</span></span><br><span class="line"><span class="comment"># 70199659366560</span></span><br><span class="line"><span class="number">5</span>.times <span class="keyword">do</span></span><br><span class="line">  puts <span class="symbol">:hello</span>.object_id</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># 899228</span></span><br><span class="line"><span class="comment"># 899228</span></span><br><span class="line"><span class="comment"># 899228</span></span><br></pre></td></tr></table></figure><br><ul><li>Symbol 效能較好 / String 較差<blockquote><p>做比較的時候，Symbol 是比對 object id 是否相同，而 String 則是一個字母一個字母逐一比對。所以在效能上來說，String 在做比較的時間複雜度會隨著字母的數量而增加，但 Symbol 的比較因為只比較是不是同一顆物件，所以它的複雜度是固定的。</p></blockquote></li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p <span class="string">"abc"</span> == <span class="string">"abc"</span>           <span class="comment"># true</span></span><br><span class="line">p <span class="string">"abc"</span>.equal?(<span class="string">"abc"</span>)      <span class="comment"># false</span></span><br><span class="line">p <span class="symbol">:abc</span> == <span class="symbol">:abc</span>             <span class="comment"># true</span></span><br><span class="line">p <span class="symbol">:abc</span>.equal?(<span class="symbol">:abc</span>)        <span class="comment"># true</span></span><br></pre></td></tr></table></figure><br><ul><li>Symbol 可使用的方法較少 / String 較多（Symbol class 的某些方法與 String class 的方法具有相同的名稱和功能）</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">:hello</span>.length                  <span class="comment"># 5</span></span><br><span class="line"><span class="symbol">:hello</span>.upcase                  <span class="comment"># :HELLO</span></span><br><span class="line"><span class="symbol">:hello</span>[<span class="number">0</span>]                      <span class="comment"># "h"</span></span><br><span class="line"><span class="symbol">:<span class="string">"foobar--"</span></span>.capitalize         <span class="comment"># "Foobar--"</span></span><br><span class="line"><span class="symbol">:foo</span>.encoding                  <span class="comment"># #&lt;Encoding:US-ASCII&gt;</span></span><br><span class="line"><span class="symbol">:</span>哈哈.encoding                  <span class="comment"># #&lt;Encoding:UTF-8&gt;</span></span><br></pre></td></tr></table></figure><br><ul><li>Symbol 內容無法更動 / String 可以</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p <span class="symbol">:symbol</span>           <span class="comment"># :symbol</span></span><br><span class="line">p <span class="string">"symbol"</span>          <span class="comment"># "symbol"</span></span><br><span class="line">p <span class="symbol">:symbol</span>[<span class="number">2</span>]        <span class="comment"># m</span></span><br><span class="line">p <span class="string">"symbol"</span>[<span class="number">2</span>]       <span class="comment"># m</span></span><br><span class="line"><span class="symbol">:symbol</span>[<span class="number">2</span>] = <span class="string">"k"</span>    <span class="comment"># error</span></span><br><span class="line"><span class="string">"symbol"</span>[<span class="number">2</span>] = <span class="string">"k"</span></span><br></pre></td></tr></table></figure><br><ul><li>如果把 String 給”冰凍”(freeze)起來，它便不可修改，object id 也會是同樣的。</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>.times <span class="keyword">do</span></span><br><span class="line">  puts <span class="string">"hello"</span>.freeze.object_id</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># =&gt; 70314415546380</span></span><br><span class="line"><span class="comment"># =&gt; 70314415546380</span></span><br><span class="line"><span class="comment"># =&gt; 70314415546380</span></span><br></pre></td></tr></table></figure><br><h3 id="Symbol-與-String-的轉換"><a href="#Symbol-與-String-的轉換" class="headerlink" title="Symbol 與 String 的轉換"></a>Symbol 與 String 的轉換</h3><ul><li>String 轉 Symbol：</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p <span class="string">"foo"</span>.intern                   <span class="comment"># :foo</span></span><br><span class="line">p <span class="string">"foo"</span>.intern.to_s == <span class="string">"foo"</span>     <span class="comment"># true</span></span><br></pre></td></tr></table></figure><ul><li>Symbol 轉 String：</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p <span class="symbol">:foo</span>.id2name                   <span class="comment"># "foo"</span></span><br><span class="line">p <span class="symbol">:foo</span>.id2name.intern == <span class="symbol">:foo</span>    <span class="comment"># true</span></span><br></pre></td></tr></table></figure><br><hr><br><h2 id="Symbol-的使用時機"><a href="#Symbol-的使用時機" class="headerlink" title="Symbol 的使用時機"></a>Symbol 的使用時機</h2><blockquote><p>由於 Symbol 不可變更(immutable)，以及效能較好，當內容不會變動，又不需要使用 String 的那麼多方法時，即可使用 Symbol。</p></blockquote><p>例如：</p><ul><li>Hash 中的 Key</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">profile = &#123; <span class="symbol">name:</span> <span class="string">"Chai"</span>, <span class="symbol">age:</span> <span class="number">18</span> &#125;   <span class="comment"># &#123;:name=&gt;"Chai", :age=&gt;18&#125;</span></span><br></pre></td></tr></table></figure><br><ul><li>Rails 的方法裡</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span></span></span><br><span class="line">  @page = Page.find(params[<span class="symbol">:id</span>])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span></span></span><br><span class="line">  @page = Page.create(page_params)</span><br><span class="line">    <span class="keyword">if</span> page.save</span><br><span class="line">      redirect_to pages_path</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ender <span class="symbol">:new</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><br><ul><li>Proc</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">%w(A B C)</span>.map(&amp;<span class="symbol">:to_sym</span>)      <span class="comment"># [:A, :B, :C]</span></span><br></pre></td></tr></table></figure><br><blockquote><p>多數時候 String 與 Symbol 可以互換使用，但也有只能使用 Symbol 或 String 的狀況，使用前務必詳閱 API 手冊。</p></blockquote><br><hr><p>參考資料:<br><a href="https://ruby-doc.org/core-2.5.0/Symbol.html" target="_blank" rel="noopener">https://ruby-doc.org/core-2.5.0/Symbol.html</a><br><a href="https://docs.ruby-lang.org/ja/latest/class/Symbol.html" target="_blank" rel="noopener">https://docs.ruby-lang.org/ja/latest/class/Symbol.html</a><br><a href="https://kaochenlong.com/2016/04/25/string-and-symbol/" target="_blank" rel="noopener">https://kaochenlong.com/2016/04/25/string-and-symbol/</a><br><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-rubysbl/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-cn-rubysbl/index.html</a><br><a href="https://pjchender.github.io/2017/09/26/ruby-symbol%EF%BC%88%E7%AC%A6%E8%99%9F%EF%BC%89/" target="_blank" rel="noopener">https://pjchender.github.io/2017/09/26/ruby-symbol%EF%BC%88%E7%AC%A6%E8%99%9F%EF%BC%89/</a><br><a href="https://ithelp.ithome.com.tw/articles/10161202" target="_blank" rel="noopener">https://ithelp.ithome.com.tw/articles/10161202</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在學 Ruby 時，常常會看到 :name 等，前面帶有冒號的字，那到底是什麼呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="學習日誌" scheme="https://chaichai.site/categories/%E5%AD%B8%E7%BF%92%E6%97%A5%E8%AA%8C/"/>
    
    
      <category term="Ruby" scheme="https://chaichai.site/tags/Ruby/"/>
    
      <category term="Rails" scheme="https://chaichai.site/tags/Rails/"/>
    
      <category term="學習日誌" scheme="https://chaichai.site/tags/%E5%AD%B8%E7%BF%92%E6%97%A5%E8%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Welcome</title>
    <link href="https://chaichai.site/2019/10/01/welcome/"/>
    <id>https://chaichai.site/2019/10/01/welcome/</id>
    <published>2019-09-30T16:00:00.000Z</published>
    <updated>2019-10-30T03:44:08.428Z</updated>
    
    <content type="html"><![CDATA[<p>Hi 我是柴柴，目前學習程式大約三個月，連 Junior 都還不敢自稱 XD<br>由於我是個不折不口的語言控，不論中文、英文、日文，還是程式語言，只要是關於語言的話題都歡迎與我交流～<br>為了整理自己所學的概念，這裡放了我的學習日誌，希望可以對自己和找尋資料的人有一些幫助，如果有寫錯的地方還請不吝於指教。</p><a id="more"></a><p>除了 blog，也可以在 Medium 上找到我唷！<br><a href="https://medium.com/@wown0710" target="_blank" rel="noopener">Chai’s Medium</a></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hi 我是柴柴，目前學習程式大約三個月，連 Junior 都還不敢自稱 XD&lt;br&gt;由於我是個不折不口的語言控，不論中文、英文、日文，還是程式語言，只要是關於語言的話題都歡迎與我交流～&lt;br&gt;為了整理自己所學的概念，這裡放了我的學習日誌，希望可以對自己和找尋資料的人有一些幫助，如果有寫錯的地方還請不吝於指教。&lt;/p&gt;
    
    </summary>
    
    
      <category term="學習日誌" scheme="https://chaichai.site/categories/%E5%AD%B8%E7%BF%92%E6%97%A5%E8%AA%8C/"/>
    
    
      <category term="雜談" scheme="https://chaichai.site/tags/%E9%9B%9C%E8%AB%87/"/>
    
  </entry>
  
</feed>
